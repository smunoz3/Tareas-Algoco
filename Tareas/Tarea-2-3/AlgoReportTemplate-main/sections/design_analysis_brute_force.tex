\epigraph{\textit{``Indeed, brute force is a perfectly good technique in many cases; the real question is, can we use brute force in such a way that we avoid the worst-case behavior?''}}{--- \citeauthor{taocv3}, \citeyear{taocv3} \cite{taocv3}}

\begin{algorithm}[H]
    \SetKwProg{myproc}{Procedure}{}{}
    \SetKwFunction{AlgorithmName}{AlgorithmName}  % Cambia 'AlgorithmName' por el nombre del enfoque elegido
    \SetKwFunction{AuxiliaryFunction}{AuxiliaryFunction}  % Función auxiliar de ejemplo
    
    \DontPrintSemicolon
    \footnotesize

    % Definición del algoritmo principal
    \myproc{\AlgorithmName{S1, S2}}{
    \uIf{S1 está vacía}{
        \Return longitud de S2\;  % Return explícito si S1 está vacía
    }
    \uElseIf{S2 está vacía}{
        \Return longitud de S1\;  % Return explícito si S2 está vacía
    }
    \uElseIf{S1[0] = S2[0]}{
        \Return \AlgorithmName{S1[1:], S2[1:]}  % Llamada recursiva
    }
    \Else{
        % Ejemplo de llamado a una función auxiliar
        $costo \leftarrow \AuxiliaryFunction{S1, S2}$\;
        \Return costo\;  % Retornar el valor calculado
    }
    }

    % Definición de la función auxiliar
    \myproc{\AuxiliaryFunction{S1, S2}}{
    % Acciones o cálculos auxiliares
    \uIf{S1 y S2 son similares}{
        \Return algún valor o costo\;  % Retornar el valor calculado por la función auxiliar
    }
    \Else{
        % Llamar de nuevo a la función principal
        \Return \AlgorithmName{S1 modificado, S2}\;  % Llamada recursiva y retorno del resultado
    }
    }
    \caption{Este es solo un ejemplo de cómo estructurar el pseudocódigo, con retornos explícitos y llamados a funciones.}
    \label{alg:mi_algoritmo_1}
\end{algorithm}